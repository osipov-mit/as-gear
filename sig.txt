
ae {
  start: 90,
  end: 1103,
  debugInfoRef: 0,
  source: <ref *1> Tn {
    kind: 0,
    range: ae { start: 0, end: 1126, debugInfoRef: 0, source: [Circular *1] },
    sourceKind: 0,
    normalizedPath: 'assembly/io.ts',
    text: "import { CodecClass, ScaleString, U8, Vec } from 'as-scale-codec/assembly';\n" +
      '\n' +
      '//@ts-ignore\n' +
      '@codec\n' +
      'class MyStruct extends CodecClass {\n' +
      '  field1: ScaleString | null;\n' +
      '  field2: Vec<U8> | null;\n' +
      '\n' +
      '  constructor(f1: ScaleString | null = null, f2: Vec<U8> | null = null) {\n' +
      '    super();\n' +
      '    this.field1 = f1;\n' +
      '    this.field2 = f2;\n' +
      '  }\n' +
      '\n' +
      '  decode(value: Uint8Array): void {\n' +
      '    this.field1 = new ScaleString();\n' +
      '    this.field1.decode(value);\n' +
      '    this.field2 = new Vec<U8>();\n' +
      '    this.field2.decode(value.slice(this.field1.bytesLen));\n' +
      '    this._bytesLen = this.field1.bytesLen + this.field2.bytesLen;\n' +
      '  }\n' +
      '\n' +
      '  encode(): Uint8Array {\n' +
      '    const field1Encoded = this.field1!.encode();\n' +
      '    const field2Encoded = this.field2!.encode();\n' +
      '    this._bytes = new Uint8Array(field1Encoded.byteLength + field2Encoded.byteLength);\n' +
      '    this._bytes.set(field1Encoded);\n' +
      '    this._bytes.set(field2Encoded, field1Encoded.byteLength);\n' +
      '    this._bytesLen = this._bytes.length;\n' +
      '    return this._bytes;\n' +
      '  }\n' +
      '\n' +
      '  static decode(value: Uint8Array): MyStruct {\n' +
      '    const result = new MyStruct();\n' +
      '    result.decode(value);\n' +
      '    return result;\n' +
      '  }\n' +
      '}\n' +
      '\n' +
      'export { MyStruct };\n',
    statements: [ [Sn], [In], [Za] ],
    debugInfoIndex: -1,
    exportPaths: null,
    lineCache: null,
    lineColumn: 1,
    internalPath: 'assembly/io',
    simplePath: 'io'
  }
}
SIGNATURE
Tr {
  kind: 2,
  range: ae { start: 1107, end: 1132, debugInfoRef: 0 },
  isNullable: false,
  currentlyResolving: false,
  parameters: [
    di {
      kind: 5,
      range: [ae],
      parameterKind: 0,
      name: [Xe],
      type: [xr],
      initializer: null,
      implicitFieldDeclaration: null,
      flags: 0
    }
  ],
  returnType: xr {
    kind: 1,
    range: ae { start: 1128, end: 1132, debugInfoRef: 0 },
    isNullable: false,
    currentlyResolving: false,
    name: hi { kind: 3, range: [ae], identifier: [Xe], next: null },
    typeArguments: null
  },
  explicitThisType: null
}
Tr {
  kind: 2,
  range: ae {
    start: 334,
    end: 359,
    debugInfoRef: 0,
    source: Tn {
      kind: 0,
      range: [ae],
      sourceKind: 0,
      normalizedPath: 'assembly/io.ts',
      text: "import { CodecClass, ScaleString, U8, Vec } from 'as-scale-codec/assembly';\n" +
        '\n' +
        '//@ts-ignore\n' +
        '@codec\n' +
        'class MyStruct extends CodecClass {\n' +
        '  field1: ScaleString | null;\n' +
        '  field2: Vec<U8> | null;\n' +
        '\n' +
        '  constructor(f1: ScaleString | null = null, f2: Vec<U8> | null = null) {\n' +
        '    super();\n' +
        '    this.field1 = f1;\n' +
        '    this.field2 = f2;\n' +
        '  }\n' +
        '\n' +
        '  decode(value: Uint8Array): void {\n' +
        '    this.field1 = new ScaleString();\n' +
        '    this.field1.decode(value);\n' +
        '    this.field2 = new Vec<U8>();\n' +
        '    this.field2.decode(value.slice(this.field1.bytesLen));\n' +
        '    this._bytesLen = this.field1.bytesLen + this.field2.bytesLen;\n' +
        '  }\n' +
        '\n' +
        '  encode(): Uint8Array {\n' +
        '    const field1Encoded = this.field1!.encode();\n' +
        '    const field2Encoded = this.field2!.encode();\n' +
        '    this._bytes = new Uint8Array(field1Encoded.byteLength + field2Encoded.byteLength);\n' +
        '    this._bytes.set(field1Encoded);\n' +
        '    this._bytes.set(field2Encoded, field1Encoded.byteLength);\n' +
        '    this._bytesLen = this._bytes.length;\n' +
        '    return this._bytes;\n' +
        '  }\n' +
        '\n' +
        '  static decode(value: Uint8Array): MyStruct {\n' +
        '    const result = new MyStruct();\n' +
        '    result.decode(value);\n' +
        '    return result;\n' +
        '  }\n' +
        '}\n' +
        '\n' +
        'export { MyStruct };\n',
      statements: [Array],
      debugInfoIndex: -1,
      exportPaths: null,
      lineCache: null,
      lineColumn: 1,
      internalPath: 'assembly/io',
      simplePath: 'io'
    }
  },
  isNullable: false,
  currentlyResolving: false,
  parameters: [
    di {
      kind: 5,
      range: [ae],
      parameterKind: 0,
      name: [Xe],
      type: [xr],
      initializer: null,
      implicitFieldDeclaration: null,
      flags: 0
    }
  ],
  returnType: xr {
    kind: 1,
    range: ae { start: 355, end: 359, debugInfoRef: 0, source: [Tn] },
    isNullable: false,
    currentlyResolving: false,
    name: hi { kind: 3, range: [ae], identifier: [Xe], next: null },
    typeArguments: []
  },
  explicitThisType: null
}
PARAMETERS
[
  di {
    kind: 5,
    range: ae { start: 1108, end: 1125, debugInfoRef: 0 },
    parameterKind: 0,
    name: Xe { kind: 6, range: [ae], text: 'value', isQuoted: false },
    type: xr {
      kind: 1,
      range: [ae],
      isNullable: false,
      currentlyResolving: false,
      name: [hi],
      typeArguments: null
    },
    initializer: null,
    implicitFieldDeclaration: null,
    flags: 0
  }
]
[
  di {
    kind: 5,
    range: ae { start: 335, end: 352, debugInfoRef: 0, source: [Tn] },
    parameterKind: 0,
    name: Xe { kind: 6, range: [ae], text: 'value', isQuoted: false },
    type: xr {
      kind: 1,
      range: [ae],
      isNullable: false,
      currentlyResolving: false,
      name: [hi],
      typeArguments: []
    },
    initializer: null,
    implicitFieldDeclaration: null,
    flags: 0
  }
]
PARAMETER TYPE
xr {
  kind: 1,
  range: ae { start: 1115, end: 1125, debugInfoRef: 0 },
  isNullable: false,
  currentlyResolving: false,
  name: hi {
    kind: 3,
    range: ae { start: 1115, end: 1125, debugInfoRef: 0 },
    identifier: Xe { kind: 6, range: [ae], text: 'Uint8Array', isQuoted: false },
    next: null
  },
  typeArguments: null
}
xr {
  kind: 1,
  range: ae {
    start: 342,
    end: 352,
    debugInfoRef: 0,
    source: Tn {
      kind: 0,
      range: [ae],
      sourceKind: 0,
      normalizedPath: 'assembly/io.ts',
      text: "import { CodecClass, ScaleString, U8, Vec } from 'as-scale-codec/assembly';\n" +
        '\n' +
        '//@ts-ignore\n' +
        '@codec\n' +
        'class MyStruct extends CodecClass {\n' +
        '  field1: ScaleString | null;\n' +
        '  field2: Vec<U8> | null;\n' +
        '\n' +
        '  constructor(f1: ScaleString | null = null, f2: Vec<U8> | null = null) {\n' +
        '    super();\n' +
        '    this.field1 = f1;\n' +
        '    this.field2 = f2;\n' +
        '  }\n' +
        '\n' +
        '  decode(value: Uint8Array): void {\n' +
        '    this.field1 = new ScaleString();\n' +
        '    this.field1.decode(value);\n' +
        '    this.field2 = new Vec<U8>();\n' +
        '    this.field2.decode(value.slice(this.field1.bytesLen));\n' +
        '    this._bytesLen = this.field1.bytesLen + this.field2.bytesLen;\n' +
        '  }\n' +
        '\n' +
        '  encode(): Uint8Array {\n' +
        '    const field1Encoded = this.field1!.encode();\n' +
        '    const field2Encoded = this.field2!.encode();\n' +
        '    this._bytes = new Uint8Array(field1Encoded.byteLength + field2Encoded.byteLength);\n' +
        '    this._bytes.set(field1Encoded);\n' +
        '    this._bytes.set(field2Encoded, field1Encoded.byteLength);\n' +
        '    this._bytesLen = this._bytes.length;\n' +
        '    return this._bytes;\n' +
        '  }\n' +
        '\n' +
        '  static decode(value: Uint8Array): MyStruct {\n' +
        '    const result = new MyStruct();\n' +
        '    result.decode(value);\n' +
        '    return result;\n' +
        '  }\n' +
        '}\n' +
        '\n' +
        'export { MyStruct };\n',
      statements: [Array],
      debugInfoIndex: -1,
      exportPaths: null,
      lineCache: null,
      lineColumn: 1,
      internalPath: 'assembly/io',
      simplePath: 'io'
    }
  },
  isNullable: false,
  currentlyResolving: false,
  name: hi {
    kind: 3,
    range: ae { start: 342, end: 352, debugInfoRef: 0, source: [Tn] },
    identifier: Xe { kind: 6, range: [ae], text: 'Uint8Array', isQuoted: false },
    next: null
  },
  typeArguments: []
}
RETURN TYPE
xr {
  kind: 1,
  range: ae { start: 1128, end: 1132, debugInfoRef: 0 },
  isNullable: false,
  currentlyResolving: false,
  name: hi {
    kind: 3,
    range: ae { start: 1128, end: 1132, debugInfoRef: 0 },
    identifier: Xe { kind: 6, range: [ae], text: 'void', isQuoted: false },
    next: null
  },
  typeArguments: null
}
xr {
  kind: 1,
  range: ae {
    start: 355,
    end: 359,
    debugInfoRef: 0,
    source: Tn {
      kind: 0,
      range: [ae],
      sourceKind: 0,
      normalizedPath: 'assembly/io.ts',
      text: "import { CodecClass, ScaleString, U8, Vec } from 'as-scale-codec/assembly';\n" +
        '\n' +
        '//@ts-ignore\n' +
        '@codec\n' +
        'class MyStruct extends CodecClass {\n' +
        '  field1: ScaleString | null;\n' +
        '  field2: Vec<U8> | null;\n' +
        '\n' +
        '  constructor(f1: ScaleString | null = null, f2: Vec<U8> | null = null) {\n' +
        '    super();\n' +
        '    this.field1 = f1;\n' +
        '    this.field2 = f2;\n' +
        '  }\n' +
        '\n' +
        '  decode(value: Uint8Array): void {\n' +
        '    this.field1 = new ScaleString();\n' +
        '    this.field1.decode(value);\n' +
        '    this.field2 = new Vec<U8>();\n' +
        '    this.field2.decode(value.slice(this.field1.bytesLen));\n' +
        '    this._bytesLen = this.field1.bytesLen + this.field2.bytesLen;\n' +
        '  }\n' +
        '\n' +
        '  encode(): Uint8Array {\n' +
        '    const field1Encoded = this.field1!.encode();\n' +
        '    const field2Encoded = this.field2!.encode();\n' +
        '    this._bytes = new Uint8Array(field1Encoded.byteLength + field2Encoded.byteLength);\n' +
        '    this._bytes.set(field1Encoded);\n' +
        '    this._bytes.set(field2Encoded, field1Encoded.byteLength);\n' +
        '    this._bytesLen = this._bytes.length;\n' +
        '    return this._bytes;\n' +
        '  }\n' +
        '\n' +
        '  static decode(value: Uint8Array): MyStruct {\n' +
        '    const result = new MyStruct();\n' +
        '    result.decode(value);\n' +
        '    return result;\n' +
        '  }\n' +
        '}\n' +
        '\n' +
        'export { MyStruct };\n',
      statements: [Array],
      debugInfoIndex: -1,
      exportPaths: null,
      lineCache: null,
      lineColumn: 1,
      internalPath: 'assembly/io',
      simplePath: 'io'
    }
  },
  isNullable: false,
  currentlyResolving: false,
  name: hi {
    kind: 3,
    range: ae { start: 355, end: 359, debugInfoRef: 0, source: [Tn] },
    identifier: Xe { kind: 6, range: [ae], text: 'void', isQuoted: false },
    next: null
  },
  typeArguments: []
}
[2K[1GDone in 0.68s.

 

 >  Lerna (powered by Nx)   Successfully ran target asbuild:debug for project struct


# @./wasm-proc --skip-stack-end build/struct.wasm
# @rm -f build/struct*.meta.wasm
# @ls -l build/struct*.wasm
